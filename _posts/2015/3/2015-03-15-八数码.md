---
layout:     post
title:      八数码 笔记
date:       2015-03-15 23:58
summary:    bfs + link list
categories: ACM
---

## 问题
``` ruby
1 2 3      2 3 4
4 5 6  ->  5 6 7
7 8        8 1
```
大概这样一个格子 问最少挪多少步可以到达一个给定的目标

## 主程序用了 bfs (无权重图找最短路)

原理很简单 从出发点开始找出所有挪出来的情况 然后再挪

``` ruby
1 2 3     1 2 3
4 5 6  -> 4 5   -> ...
7 8       7 8 6
  |
1 2 3
4 5 6  -> ...
7   8
```

但是不同于之前的bfs 这回如果要怒开 vis 数组就要开一个 vis[9][9]...[9] 九位数组

但是这没必要的, 因为总的permutation 不是 9^9 而是 9!

所以如果要最简单的办法就是将每一种可能性变成一个 9 位数

e.g. `[1,2,3,4,5,6,7,8,0]` => `123456780`

可是 9位数的数组依然太大 所以要用 hash去做

书里面用的 size 是 100003 所以所有的 九位数都可以被放进 100003 这么大的数组

直观一点就是这样的

``` ruby
[ st[0] ] -> [ st[100003] ] -> [ st[200006] ]
    |
[ st[1] ] -> [ st[100004] ]
    |
[ st[2] ]
    |
    .
    .
    .

```
但是链表的实现没有这么直观 要用两个数组一起弄 `head` `next`

`head` 和 `next` 都要同样有 100003

`head` 中存着指向实际数组的指针 `st` 是实际的数组(八数码状态数组) 初始状态都是0(没有指向任何东西)

``` ruby
head
[0] -> st[100]
[1] -> st[3000]
[2] -> 0
 .
 .
 .
```

`next` 是链表的指向 implicitly 所有的 index 都指向 st[index]

e.g. `next[0] => st[0]` , `next[100003] => st[100003]`

当 `next[n] == 0` 的时候 链表就就结束了

``` ruby
next
[0] -> 100003
[1] -> 0
[2] -> 0
[3] -> 0
 .
[100003] -> 200006
 .
```
